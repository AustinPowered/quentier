<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
	<meta name="generator" content="Hugo 0.26" />
  <link href="https://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  

  <title> Quentier </title>

  
  <link rel="stylesheet" href="https://d1vanov.github.io/quentier/css/poole.css">
  <link rel="stylesheet" href="https://d1vanov.github.io/quentier/css/syntax.css">
  <link rel="stylesheet" href="https://d1vanov.github.io/quentier/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">

  
  <link rel="apple-touch-icon" sizes="180x180" href="/quentier/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/quentier/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/quentier/favicon-16x16.png">
  <link rel="manifest" href="/quentier/manifest.json">
  <link rel="mask-icon" href="/quentier/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="theme-color" content="#ffffff">

  
  <link href="https://d1vanov.github.io/quentier/index.xml" rel="alternate" type="application/rss+xml" title="Quentier" />
  <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

  <link href='https://fonts.googleapis.com/css?family=Fira+Sans:400,300' rel='stylesheet' type='text/css'>

  <script src="//ajax.googleapis.com/ajax/libs/webfont/1.4.7/webfont.js"></script>
  <script>
    WebFont.load({
      google: {
        families: ['Fira Sans']
      }
    });
  </script>

</head>

<body class="theme-base-0d">

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about" align=center>
      <h1 class="brand"><a href="https://d1vanov.github.io/quentier">Quentier</a></h1>
      <img src="/quentier/quentier_icon.svg" width=50% />
      <p class="lead">
         Free &amp; open source desktop Evernote client 
      </p>
    </div>
    <ul class="sidebar-nav">
      <li><a href="https://d1vanov.github.io/quentier/blog">Posts</a></li>
      
      <br/> 
    </ul>
     
    
    
     <a href="https://github.com/d1vanov"><i class="fa fa-github-square"></i></a>&nbsp;&nbsp; 
     

    <p class="footnote">powered by <a href="http://gohugo.io">Hugo</a> <br/> &copy; 2018 Dmitry Ivanov. All rights reserved.</p>

  </div>
</div>


    <div class="content container">
<div class="posts">

      
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://d1vanov.github.io/quentier/blog/quentier-technical-overview/">
        Quentier internals overview
      </a>
    </h1>

    <span class="post-date">Jan 7, 2018</span>

    
      
      <p class="seriesname">Series: <a href="https://d1vanov.github.io/quentier/series/developers-guide">Developers guide</a></p>
    


    <p>This post is primarily for developers who would like to contribute to Quentier but aren&rsquo;t quite sure where to start. Here the high-level overview of the app design is explained.</p>

<p>First, let&rsquo;s briefly enumerate the kinds of technology used in Quentier project:</p>

<ul>
<li>Qt/C++</li>
<li>CMake</li>
<li>SQLite</li>
<li>JavaScript</li>
<li>CSS (a bit)</li>
</ul>

<p>If you are familiar with any of these technologies, you are most likely able to help developing Quentier! However, note that there are some specific ways in which these technologies are used in the project. For example, currently the list of supported Qt versions ranges from Qt 4.8.6 to the latest and greatest Qt 5.x. However, Qt 4.8.6 is only really supported on Linux while on Windows and on Mac it&rsquo;s much more reasonable to use newer Qt 5.x.</p>

<p>Another point is that even though C++ is known as a hard to grasp language for system programmers, in Quentier project only a relatively simple subset of it is used - the use of exceptions is very limited, most part of the code is written in C++98 style with only a handful of features from C++11 standard employed. That makes is possible to build Quentier using as old compilers as gcc-4.5 or Visual C++ 2010. In future the support for such old compilers is going to be dropped at some point though in order to use more useful features from mode recent C++ standards.</p>

<p>The core functionality of Quentier is encapsulated in <a href="https://github.com/d1vanov/libquentier">libquentier</a> library which is distributed under the terms of GNU LGPL v.3. It has no tight bindings to Quentier application (otherwise it won&rsquo;t make much sense to make it a separate library at all) so it can be used by other applications as well. Libquentier provides the following essential functionality:</p>

<ol>
<li>Local storage of notes, notebooks, tags, saved searches, resources. The data elements of each kind can be added, updated, removed, listed, looked up etc.</li>
<li>Synchronization of data from local storage with Evernote servers. Both full and partial synchronization algorithms are implemented.</li>
<li>Note editor UI component which enables one to view and edit notes.</li>
<li>Conversion between ENML and HTML used for presenting notes within the note editor.</li>
<li>A bunch of utility functions and classes.</li>
</ol>

<p>Libquentier&rsquo;s functionality is in turn based on <a href="https://github.com/d1vanov/QEverCloud">QEverCloud</a> library which essentially is the Qt-friendly replacement of the official Evernote C++ SDK: QEverCloud handles the transmission of data between Evernote servers and the outside world and also offers nice Qt-friendly API. A large part of QEverCloud&rsquo;s code was generated automatically from <a href="https://github.com/evernote/evernote-thrift">Evernote thrift IDL files</a>. IDL stands for &ldquo;interface definition language&rdquo;. Thrift was originally invented within Facebook and later on was contributed to Apache Foundation. Thrift IDL is a thing like pseudo-code only it focuses on the definitions of structs instead of commands. Thrift IDL code itself is not compiled into executable code but it can be parsed and converted to code in some real programming language. Normally the generation of code in real programming language is performed by <a href="https://thrift.apache.org/https://thrift.apache.org">thrift compiler</a> but it doesn&rsquo;t have a Qt-friendly C++ backend so QEverCloud&rsquo;s sources are generated using a custom tool - <a href="https://github.com/d1vanov/QEverCloudGenerator">QEverCloudGenerator</a>. The Qt-friendliness of the generated code means that all the most convenient Qt&rsquo;s data types are used instead of their plain C++ counterparts so no conversion between different data types needs to be done. Most notably <code>QString</code> is used instead of <code>std::string</code>.</p>

<p>The local storage within libquentier uses SQLite as its backend i.e. all user&rsquo;s data is stored within a SQLite database. However, it is just an implementation detail, the fact of SQLite usage is completely hidden from libquentier&rsquo;s public API. So in theory is is possible to change the database backend in future to whatever one is considered better - even to storage of plain text files. Internally SQLite is used via Qt&rsquo;s <code>QtSql</code> module.</p>

<p>The synchronization is implemented according to <a href="https://dev.evernote.com/media/pdf/edam-sync.pdf">Evernote&rsquo;s document</a>. That document explains a lot of details but some non-obvious subtleties are not mentioned, unfortunately, so I plan to write more about them in further posts. The synchronization of user&rsquo;s own accounts, public notebooks and notebooks shared by other users is fully supported.</p>

<p>Note editor is a very special thing within libquentier: it is unfortunately quite a complex collection of C++ classes, JavaScript code and a bit of CSS. The complexity of the note editor code comes primarily from the unexpected move of Qt devs who decided to deprecate QtWebKit in favour of QtWebEngine. I decided to support both backends after the semi-complete implementation of QtWebKit based note editor. As a result, note editor&rsquo;s source code has become full of ifdefs slitting the logical branches between the two alternative backends. Another source of complexity is the support for advanced &ldquo;smart&rdquo; undo-redo stack as well as various convenient actions like resizing images, resizing table columns etc.</p>

<p>ENML converter serves the needs of the note editor: it performs the conversion between <a href="https://dev.evernote.com/doc/articles/enml.php">ENML</a> which is Evernote&rsquo;s format for note content storage and HTML. Currently this converter has some hardcoded parts to best serve the needs of the note editor. It would be nice to add some configurability to it in future.</p>

<p>Quentier app&rsquo;s source code is mostly about handling various aspects of user interface and orchestration of work performed by the code within libquentier. Here are the primary parts of Quentier app&rsquo;s code:</p>

<ol>
<li><code>AccountManager</code>: this class controls the discovery of available and last used accounts, switching between accounts and other account management details.</li>
<li><code>MainWindow</code>: this class is the central class within the entire app and it represents, as its name suggests, the main window of Quentier app. It also works as the mediator between several other classes.</li>
<li><code>NoteEditorTabsAndWindowsCoordinator</code>: this class maintains the list of open note editor widgets, both tabbed ones and editors in separate windows. For performance and memory consumption concerns tabbed note editor widgets are automatically closed as new tabbed note editors are opened i.e. the <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_Recently_Used_(LRU)">LRU cache</a> of tabbed note editors is maintained. The contents of automatically closed note editor tabs are automatically saved, of course, so no loss of data occurs.</li>
<li><code>SystemTrayIconManager</code>: this class, as its name suggests, maintains the Quentier&rsquo;s system tray icon and handles various actions which might be requested from the tray icon&rsquo;s context menu.</li>
<li><code>EnexExporter</code> and <code>EnexImporter</code> are two helper classes which orchestrate the libqentier&rsquo;s code performing export and import of notes to and from data in ENEX format.</li>
<li>Models: classes from <code>src/models</code> folder within Quentier&rsquo;s source tree. These are models in <a href="https://doc.qt.io/qt-5/model-view-programming.html">Qt&rsquo;s model-view framework</a> sense: each is a subclass of <a href="https://doc.qt.io/qt-5/qabstractitemmodel.html">QAbstractItemModel</a>. There are several such classes:

<ul>
<li><code>FavoritesModel</code> - contains data about favorited data items within the current account</li>
<li><code>NotebookModel</code> - contains data about notebooks within the current account</li>
<li><code>TagModel</code> - contains data about tags within the current account</li>
<li><code>SavedSearchModel</code> - contains data about saved searches within the current account</li>
<li><code>NoteModel</code> - contains data about notes within the current account</li>
<li><code>NoteFilterModel</code> - subclass of <a href="https://doc.qt.io/qt-5/qabstractitemmodel.html">QSortFilterProxyModel</a>, implements filtering over the list of notes (sorting is implemented within the <code>NoteModel</code> itself)</li>
<li><code>LogViewerModel</code> - subclass of <a href="https://doc.qt.io/qt-5/qabstracttablemodel.html">QAbstractTableModel</a>, contains data parsed from Quentier&rsquo;s log file; serves for convenient visual presentation of the log file&rsquo;s contents</li>
</ul></li>
<li>Views: classes from <code>src/views</code> folder within Quentier&rsquo;s source tree. These are views in <a href="https://doc.qt.io/qt-5/model-view-programming.html">Qt&rsquo;s model-view framework</a> sense: each is a subclass of <a href="https://doc.qt.io/qt-5/qtreeview.html">QTreeView</a> or <a href="https://doc.qt.io/qt-5/qlistview.html">QListView</a>. There are several such classes:

<ul>
<li><code>ItemView</code> - intermediate helper class within the inheritance chain between <code>QTreeView</code> and particular Quentier&rsquo;s view classes</li>
<li><code>NotebookItemView</code> - implements various actions available via context menu on notebooks from this view as well as special behaviour on notebook selection - the list of notes is filtered by the currently selected notebook unless it is a linked notebook (which is the current technical limitation due to the possibility of name clashes between notebooks from user&rsquo;s own account and linked notebooks or between different linked notebooks)</li>
<li><code>TagItemView</code> - implements various actions available via context menu on tags from this view</li>
<li><code>SavedSearchItemView</code> - implements various actions available via context menu on saved searches from this view</li>
<li><code>DeletedNoteItemView</code> - implements various actions available via context menu on deleted notes from this view</li>
<li><code>NoteListView</code> - implements various actions available via context menu on non-deleted notes from this view</li>
</ul></li>
<li>Delegates: classes from <code>src/delegates</code> folder within Quentier&rsquo;s source tree. These are delegates in <a href="https://doc.qt.io/qt-5/model-view-programming.html">Qt&rsquo;s model-view framework</a> sense: each is a subclass of <a href="https://doc.qt.io/qt-5/qstyleditemdelegate.html">QStyledItemDelegate</a> and implements customized rendering and/or editing of items corresponding to a particular view. I won&rsquo;t list them here since basically each mentioned view has its own delegate + there are some other delegates which are best understood by looking at how and where they are used within Quentier&rsquo;s source code.</li>
</ol>

<p>To put things into perspective, Quentier primarily consists of three large parts:</p>

<ol>
<li>Local storage</li>
<li>Synchronization</li>
<li>UI</li>
</ol>

<p>These three parts interact with each other, primarily asynchronously, via signals and slots. Local storage and synchronization operate within their own threads of execution, the UI is processed primarily in the main (GUI) thread so the operations inside it need to be fast.</p>

<p>That wraps up the brief technical overview. I intend to write more detailed posts about each of the mentioned parts so stay tuned.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://d1vanov.github.io/quentier/blog/quentier-brief-overview/">
        Brief overview of Quentier features
      </a>
    </h1>

    <span class="post-date">Dec 16, 2017</span>

    


    

<p>In this post I describe in more details what Quentier app is capable of by the current moment.</p>

<p>First of all, please note that at the time of this writing Quentier is in public alpha stage. That means the project is very fresh, some things are unpolished while some other things might just refuse to work due to some unforeseen circumstances. It is pretty normal to go through this stage for any new software project, just be aware of that and don’t expect too much from the current version. Also please report the discovered issues to the project’s <a href="https://github.com/d1vanov/quentier/issues">issue tracker</a>.</p>

<h3 id="accounts">Accounts</h3>

<p>Quentier as a note taking app can work in two modes: it can either work with <strong>local</strong> accounts or with Evernote accounts. That means you are not obliged to have Evernote account if all you want to do is managing notes with Quentier on just a single computer. Or maybe even on several computers provided that you either copy the data between computers manually or you keep the local account data on a USB stick which you mount to different computers. The latter option requires that you start Quentier with <code>--storageDir &lt;path&gt;</code> command line parameter pointing at the location of your account data. By default, if no such command line option is specified, Quentier keeps its persistent data at the following locations depending on the platform the app runs on:</p>

<ul>
<li><code>~/.quentier</code> on Linux</li>
<li><code>~/Library/Application Support/quentier.org/Quentier</code> on OS X / macOS</li>
<li><code>C:\Users\%USERNAME%\AppData\Roaming\Quentier</code> on Windows</li>
</ul>

<p>At the moment Quentier works best when only a single instance of the application is running at any moment of time. There are some protection measures against having two app instances working with the same account, however, right now if you try hard enough you might be able to fool them. It is possible to run several instances of the application working with different accounts, however, it might not work on Windows and it might screw up the usefulness of logging on other platforms since currently all instances of Quentier attempt to write logs into the same log file.</p>

<p>The preferred way to work with different accounts is to have a single instance of the application running and to switch between accounts as necessary: that can be done by opening “File” menu and choosing one of “Switch account” submenu’s options. Note that most of different settings and preferences within Quentier are persistent and account-specific. Even the relative sizes of main window’s parts are persisted and restored on per account basis.</p>

<p>When you open Quentier app for the first time, it would ask you what would you like to do: use the app for local note-taking or use it as Evernote client. The local account is created for you automatically and even if you choose to use Quentier as Evernote client, you can still switch back to the local account later. You can also create as many local and Evernote accounts as you wish and switch between them freely.</p>

<p><img src="/quentier/Welcome_to_Quentier.png" alt="Welcome to Quentier" /></p>

<p>To add a new account, open “File” menu -&gt; “Switch account” -&gt; “Add account”. You will be prompted which kind of account you want to create - either local one or Evernote one.</p>

<p><img src="/quentier/Quentier_add_account.png" alt="Quentier add account" /></p>

<p>If you choose Evernote account you will be prompted the Evernote server to use: “Evernote” means the default server used by most casual users, “Yinxiang Biji” is Chinese Evernote server and “Evernote sandbox” is mostly useful to developers - it is Evernote’s server with which the synchronization algorithms can be tested. After you choose the Evernote server to use you’ll be prompted to allow Quentier manage your Evernote account’s data.</p>

<p><img src="/quentier/Quentier_authenticate_to_Evernote.png" alt="Quentier authenticate to Evernote" /></p>

<p>It is also possible to manage the existing accounts: “File” -&gt; “Switch account” -&gt; “Manage accounts”. From the dialog you can add new accounts, revoke the authentication for particular Evernote accounts (might be useful in case of synchronization problems: revoking the authentication triggers authentication request on the next synchronization attempt) and even delete the account. Only use the latter option with great care because <strong>the removal of local accounts is permanent and cannot be reverted</strong>. The removal of Evernote account simply means unlinking Quentier from managing that account, not the permanent removal of your Evernote account, of course.</p>

<p>One other nice account-related feature is the ability to change the display name of any account - this current account’s display name is shown at the top of the main window. For example, for Evernote accounts your username would be displayed. You might want to change that to show your real name. Within “Manage accounts” dialog you can do so by entering your real name into the “Display name” column.</p>

<h3 id="user-interface">User interface</h3>

<p>On the upper part of the main window there’s a toolbox with several buttons for most frequently used actions: synchronization (for Evernote accounts), printing of current note or exporting it to PDF, deletion of current note or creation of a new one.</p>

<p><img src="/quentier/Quentier_toolbar.png" alt="Quentier toolbar" /></p>

<p>This panel also contains the note search string which can be used to filter notes by some particular criteria. The search string fully supports the <a href="https://dev.evernote.com/doc/articles/search_grammar.php">Evernote search syntax</a>. The search string can be saved (as a “saved search” data item within the account) by pressing the button to the right from the search string.</p>

<p><img src="/quentier/Quentier_note_search_string.png" alt="Quentier note search string" /></p>

<p>On the left side of Quentier’s main window there are panels displaying notebooks, tags, saved searches, favorited items and deleted notes. By default the deleted notes are not displayed but the display of them - as well as the display of all other side panels - can be toggled using the appropriate option from “View” menu. The entire left side panel can be hidden for which there’s a default keyboard shortcut - F10.</p>

<p><img src="/quentier/Quentier_left_panels.png" alt="Quentier left panels" /></p>

<p>Favorited items are similar to <a href="https://help.evernote.com/hc/en-us/articles/209004637-How-to-create-shortcuts">Evernote shortcuts</a>: they allow you to create links to most frequently used content - particular notes, notebooks, tags, saved searches - for quick access to them. However, favorited items are favorited only locally for either local or Evernote account because Evernote service doesn’t offer any API for the synchronization of favorited items or shortcuts. Or no such public API at least. Quentier is not the only Evernote client which has to cope with this restriction, <a href="http://alternoteapp.com/">Alternote</a> app describes the issue within its <a href="http://alternoteapp.com/ru/#faq">FAQ</a>.</p>

<p>The list of notebooks is really a tree view as notebooks can be nested into stacks and linked notebooks are displayed as children of special items representing users owning the corresponding linked notebooks. Notebooks can be freely moved between stacks either via context-menu or via drag-n-drop. However, it is prohibited to, say, drop user’s own notebook onto the stack corresponding to some linked notebook. Or to attempt doing the same thing across different linked notebooks.</p>

<p>Tags also form a tree structure as they can be nested into each other. Plus, tags downloaded from linked notebooks are also shown under special items representing users owning the corresponding linked notebooks. Tags nesting can be altered either via context menu or via drag-n-drop, with the same restrictions as for notebooks.</p>

<p>Saved searches list is a simple list without any kind of nesting. The query corresponding to each saved search can be edited through that saved search’s context menu.</p>

<p>The list of deleted notes shows the notes which are still persisted within the local storage (and Evernote account) but are marked as deleted. Quentier doesn’t allow the permanent removal of notes for Evernote accounts as Evernote service prohibits this possibility for third party apps. As well as the possibility to permanently remove a tag, a notebook or a saved search. It is quite a wise decision from Evernote as this way Quentier or any other third party app has no way to cause the data loss within your Evernote account - you can only potentially lose the data which has not been synced yet. Or, if you are very inattentive, you can mark the note as deleted from third party app and then wipe it from the trash can via the official Evernote client or via Evernote web client. So, pay attention when emptying the trash of Evernote notes - make sure there’s nothing of worth there.</p>

<p>The next column from the left edge of the main window is the list of notes. Each item within the list shows some information about the note: its title, creation and modification time, preview text and the thumbnail. The thumbnails are only displayed for Evernote accounts if “Show note thumbnails” preference is enabled (it is by default) and if the synchronization setting “Download note thumbnails” is enabled (it is by default). At this time there is no note table view so note list view is the only way to observe the existing notes.</p>

<p><img src="/quentier/Quentier_note_list_view.png" alt="Quentier note list view" /></p>

<p>In the upper part of the note list view there’s a widget called “Filters”, by default folded. To unfold it, press the button with left pointing arrow. The unfolded widget allows to enable filters for notes list: notebooks, tags or a saved search. The saved search filter overrides notebook and tag filters: the latter ones become disabled (greyed out) to indicate they don’t contribute to the actual filtering criteria - saved search - at the moment. Filters by notebooks, tags and saved search are all disabled when the note search string (on the upper panel, above the note editor) is not empty. I.e. filter by saved search overrides filters by notebooks and tags but note search string overrides just any filter.</p>

<p>Filtering notes by a single notebook works automatically by selecting the notebook within the list i.e. as you select different notebooks within the notebooks list, you’d see notes from the selected notebook but not from other notebooks. That’s how the official Evernote clients work so it should be fairly convenient for Evernote users.</p>

<p>Currently there’s a limitation on filtering by notebooks and tags: you can’t filter the notes by linked notebooks and tags from linked notebooks. The reasons for this are purely technical and have to do with the potential clashing of notebook and/or tag names from user’s own account and from linked notebooks. This issue would hopefully be addressed in future.</p>

<p>Slightly below the filters widget there’s a combo box allowing to pick the desired sorting criteria for the list of notes. By default the notes are sorted by modification time, the recently modified notes go first.</p>

<h3 id="note-editor">Note editor</h3>

<p>On the right side of the main window there’s one or more tabbed note editors displaying the contents of notes. Quentier by default limits the amount of open note editors in order to prevent the use of ever growing amounts of memory. It happens automatically: if you open different notes one by one, the editors for previous notes (longest time untouched ones) automatically close. The unsaved edits made to notes within those editors are automatically saved, of course, so there is no risk of data loss. The only thing which is lost when the note editor is closed is the state of the undo stack i.e. the ability to do undo/redo for already closed note editors is gone.</p>

<p>Each note editor can be moved from tab to a separate window. For this right click on the note editor tab’s header and choose “Open in separate window” option. However, beware that once you did this, the only way to return the note editor to the tabs list is to close it and open the same note again.</p>

<p>The attachments to notes (“resources” in Evernote terminology) are represented as either images (for image attachments) or small blocks containing the name and the size of the attachment and the buttons to save the attachment to some file or open the attachment for editing. If the attachment was opened for editing within some app, Quentier would watch for changes done by the app and once the attachment file changes, it would update the resource within the note. Unfortunately at the time of this writing it is not possible to choose the application which is to be used for editing of the attachment - it appears to be highly platform specific and no standard Qt API to implement that exists.</p>

<p>The image attachments can be rotated clockwise or counterclockwise and can be resized - for that put the cursor to the right bottom edge of the image and drag it.</p>

<p>The columns of tables within notes can be resized - simply put the cursor on the border between the columns and drag it.</p>

<p>The note editor supports a wide range of undo/redo capabilities - it tries hard to intercept every possible action and account for it within the undo/redo stack. The intercepted actions include text input as well as various other manual actions like rotating the image attachments - try to rotate the image attachment and then click “Undo”. Then click “Redo”. Now you see how it works.</p>

<p>The note editor’s undo stack implementation is one of the trickiest parts of the entire project. That means, it is unfortunately considerably fragile. If it doesn’t work in some cases, please forgive it - it tries as hard as I was able to make it so. But in addition to forgiving it please file an issue on the project’s <a href="https://github.com/d1vanov/quentier/issues">issue tracker</a> - unless the issue similar to the observed one has already been submitted.</p>

<p>Quentier supports encryption and decryption of note fragments, including both modern encryption used by Evernote - AES algorithm - and the legacy encryption algorithm - RC2. Unlike Nixnote 2, Quentier doesn’t require Java for that: the encryption/decryption algorithms from OpenSSL are used instead. A side note for Mac users: Apple’s SSL implementation doesn’t have these algorithms, that’s why OpenSSL from Homebrew or Macports (or some custom OpenSSL build) is required to build libquentier and Quentier on Mac.</p>

<h3 id="features-present-in-official-evernote-apps-but-not-in-quentier">Features present in official Evernote apps but not in Quentier</h3>

<p>There are lots of them. Just about every single feature but the simplest notes, notebooks, tags and saved searches management is not implemented at this moment. Several features existing in Evernote look interesting so they might be added in future, for example, embedded PDFs within the note editor or <a href="https://help.evernote.com/hc/en-us/articles/209004967-How-to-create-import-folders-in-Evernote-for-Windows">import folders</a> functionality. However, I won’t like to give the precise list of features planned for implementation in future as that would depend on a lot of things - on the degree of public interest to Quentier, on the amount of votes for this or that particular feature, on the technical difficulty to implement such a thing and on other factors.</p>

<p>Hopefully this post gives you some idea about what Quentier is capable of right now. If you’d like to know more, give Quentier a try and evaluate its capabilities yourself.</p>

  </div>
  
  
  
  <div class="post">
    <h1 class="post-title">
      <a href="https://d1vanov.github.io/quentier/blog/helloworld/">
        Hello world!
      </a>
    </h1>

    <span class="post-date">Dec 7, 2017</span>

    


    <p>This blog is dedicated to <a href="https://github.com/d1vanov/quentier">Quentier</a> — an open source desktop note taking app which can be used as Evernote client or just for local note taking without the necessity to even have the Evernote account. Quentier is free software distributed under the terms of GNU GPL v.3. The core functionality of Quentier is encapsulated in <a href="https://github.com/d1vanov/libquentier">libquentier</a> library which is distributed under the terms of GNU LGPL v.3.</p>

<p>Let me briefly introduce myself as the author of Quentier: my name is Dmitry Ivanov, I&rsquo;m a 29 years old software developer from Saint-Petersburg, Russia. I bet I&rsquo;m not (yet) known to the free software community as my contributions to free software in the past were quite limited. Quentier is my &ldquo;pet project&rdquo; on which I&rsquo;ve been working in my free time for several last years. There is no any company or organization behind the project.</p>

<p>Here&rsquo;s how Quentier looks like:</p>

<p><img src="/quentier/Quentier_sample_screenshot.png" alt="Sample Quentier screenshot" /></p>

<p>With Quentier you can read, modify, search and create notes, put them into notebooks, label them with tags, create and manage saved searches. If you are using Quentier for working with Evernote account, you can also synchronize with Evernote service - download the data into Quentier&rsquo;s local storage, work with the content and then send changes back to Evernote. With Quentier it is absolutely possible to create and edit content offline and synchronize it with Evernote later.</p>

<p>Compared to official Evernote clients for various platforms, Quentier is a rather minimalistic one: it doesn&rsquo;t have many advanced features such as <a href="https://help.evernote.com/hc/en-us/articles/209004967-How-to-create-import-folders-in-Evernote-for-Windows">import folders</a> or PDF reader embedded into the note editor or the possibility to e-mail notes right from the app. Some of such advanced functionality might (or might not) be added to Quentier in future. However, there are some notable already supported features required for proper working with already existing notes: for example, Quentier properly supports encryption and decryption of note fragments supporting both current encryption method used by Evernote - AES - and the older legacy one - RC2.</p>

<p>Quentier maintains most of the account&rsquo;s content within a local SQLite database which allows for convenient and efficient searching of stuff. Quentier fully supports Evernote search syntax as internally it is translated into SQL queries.</p>

<p>More details on what Quentier can and cannot do and how it works will be revealed in future posts so stay tuned. The rest of this post is dedicated to project&rsquo;s history and attempts to foresee and answer some questions expected from newcomers.</p>

<!-- more -->

<p>The Quentier project was open sourced only in late 2017 although it was started long before that, in the middle of 2013. At that time I had the following situation in my life — it was about half a year since I decided to abandon the PhD program I was participating and about a year since I got permanent job of a junior software developer. My education had little to do with software development, I was a theoretical physicist and just did some mathematical modeling in Fortran. Shortly before my graduation one of my university teachers moved to a rather young company to start a new department there and he offered me to become his assistant. The job had no connection to physics at all but it was connected to mathematical modeling so I agreed. I was working part time for about a year as after my graduation I entered the PhD program. But that program didn&rsquo;t work out well for me so I quit it at some point and decided to start working full time. My employer agreed under condition that I&rsquo;d take some purely programming tasks not involving math in addition to my previous duties.</p>

<p>Shortly after starting to work on purely programming tasks I realized I lack the expertise required to solve such problems efficiently and decided to learn programming to become a more proficient developer. I started to read various books on software development but I felt it was not enough – I needed practice as well as theory and the practice I had at work wasn&rsquo;t quite enough since it was mostly about maintaining already existing working code and I tried really hard to change it minimally to not break things. So I decided to start some hobby project to work on in my free time – such project could serve as a playground for various ideas on software design which I read from books and articles as well as the ongoing source of learning various things which I&rsquo;d need to master for the project&rsquo;s completion.</p>

<p>Many people finding themselves in a similar situation seem to settle with small projects like various ToDo lists or small scripts or something similar. Other folks go for various exercises which can be found in great numbers on the Internet. Others go further and take some programming courses. I didn&rsquo;t want to participate in any courses but wanted to build something mildly complex and actually useful myself. That desire was backed by my introduction to Linux and the world of free software which happened in 2012. I became very enthusiastic about the ideas of free software and wanted to participate in its development somehow. So I did intend to open source my pet project if it ever reaches usable state.</p>

<p>By the time I switched my home computer from Windows to Linux (in 2012) I already used <a href="https://evernote.com">Evernote</a> service – I didn&rsquo;t use it very often or very much but I found it very convenient for note taking and syncing across several computers. So when I found out there is no official Evernote client for Linux, it was a disappointment. I tried Everpad and Nevernote (or Nixnote 1, the Evernote client in Java with Qt bindings) but neither seemed good enough for me. So after some thought I decided to devote my pet project to the creation of something like Evernote client for Linux myself. You can judge by that decision how much “junior” I was at the time as I could not even roughly estimate the scale of the task. If I realized how huge it was back then, you would have probably never heard of Quentier as it won&rsquo;t have ever been even started.</p>

<p>Coincidentally around the time I decided to start Quentier project I also started to tinker with the <a href="https://www.qt.io">Qt framework</a>. At work I developed things in C++ but no Qt. I learned about Qt framework&rsquo;s existence somewehere on KDE forums and decided that&rsquo;s just what I need for writing GUI apps in C++ which would also be cross-platform.</p>

<p>So the pet project&rsquo;s technological set was mostly determined – Qt and C++. I need to master C++ because that&rsquo;s what I code in at work and I need Qt if I want to make nice cross-platform apps. One other piece of technology I learned about from watching the KDE project was <a href="https://cmake.org/">CMake</a> build system. From a brief look it seemed much more powerful than <a href="http://doc.qt.io/qt-5/qmake-manual.html">qmake</a> so I decided to learn and use it.</p>

<p>One might ask why I didn&rsquo;t come to help build <a href="https://github.com/baumgarr/nixnote2">Nixnote 2</a> instead as it also used Qt and C++. The answer is simple – I had no idea of Nixnote 2&rsquo;s existence. I&rsquo;ll return to discussing Nixnote 2 a bit later in this post.</p>

<p>So in the second half of 2013 I created a private repository on <a href="https://bitbucket.org">bitbucket</a> and started to tinker with the official <a href="https://github.com/evernote/evernote-sdk-cpp">Evernote C++ SDK</a> and its dependencies trying to put something together. I had little idea of how to structure whatever I was building so for the first 7-8 months I just did random things like the main window&rsquo;s UI created in Qt Designer, some basic note editor based on <code>QTextEdit</code> and <code>QTextDocument</code> and various other small things. After I realized I have no idea where I&rsquo;m going I decided to put the code aside and try to come up with some high level architecture which I would then implement piece by piece. After some thought I figured there are just three large required components interacting with each other:</p>

<ol>
<li>Local storage</li>
<li>Synchronization</li>
<li>GUI</li>
</ol>

<p>Fortunately, by that time I learned some basics about multithreading and figured that operations with local storage and synchronizaton should be done in background threads and not block the UI thread. So the threading model was also quite simple initially: local storage controller runs in its own thread, the synchronization controller also runs in its own thread and they communicate with each other and with GUI asynchronously, by sending data via signals and slots.</p>

<p>Once that concept was worked out, I started to implement the local storage part. Quick googling revealed the industry standard for embedded databases is <a href="https://www.sqlite.org/">SQLite</a> so I read a book on SQL basics in context of SQLite and got to coding. Fortunately, I was aware of <code>QtSql</code> module&rsquo;s existence which simplified the coding of database management for me.</p>

<p>Shortly after I started to implement the local storage component I learned about the existence of <a href="https://github.com/d1vanov/QEverCloud">QEverCloud</a> – the amazing Qt-friendly replacement for the official Evernote C++ SDK which was quite a pain to use – first, it had a fair share of dependencies including thrift library, some boost parts, libevent and something else which I don&rsquo;t even remember now; second, the use of the official Evernote C++ SDK involved a lot of conversions between <code>std::string</code> and <code>QString</code> which was of course nothing good. I rejoiced and converted my project to use <code>QEverCloud</code>.</p>

<p>A little later, when about 60% of the known work on the local storage was done, I occasionally learned about the existence of Nixnote 2. It felt to match exactly the niche of my project and even used the same technological stack – C++ and Qt. I was very disappointed and considered shutting my project down and switching to doing something else. For a couple of weeks I ceased the development of Quentier and tried to use Nixnote 2. At that time – mid 2014 if I remember correctly – it was quite buggy. Out of curiosity I decided to look at the source code and find the origin of some bugs which prevented me from using the app normally. I have properly traced the roots for a couple of issues and even <a href="https://github.com/baumgarr/nixnote2/pull/19">contributed</a> a simple fix for one bug. I saw a lot of interesting things within the source code of Nixnote 2 about the existence of which I had no idea previously. One thing which later affected the development of Quentier was the use of <code>QtWebKit</code> as the note editor&rsquo;s backend. My previous attempts to build the note editor were focused on employing <code>QTextEdit</code> and <code>QTextDocument</code> for that and there were quite several problems which I wasn&rsquo;t sure how to handle, for example, what to do with HTML elements which <code>QTextDocument</code> doesn&rsquo;t support but which might appear within Evernote&rsquo;s notes – there are not many such elements but they exist so just ignoring them was not an option. Furthermore, it was unclear how to embed the resources (attachments) within the note&rsquo;s text. <code>QtWebKit</code> solved both mentioned problems nicely – being the browser engine it supported HTML much better out of the box + there was a nice piece of API for the insertion of custom widgets into the page – web plugins. That was a perfect match for displaying of attachments embedded into notes.</p>

<p>I need to take a brief stop here to tell about my opinion and impression on Nixnote 2 and its author. I greatly admire the time and effort put into the development of Nixnote 2 by its author, <a href="https://github.com/baumgarr">baumgarr</a>. He was also the author of “Nixnote 1” also known as Nevernote – the free open source Evernote client implemented in Java with Qt bindings. Its first version was <a href="https://discussion.evernote.com/topic/7943-linux-guinea-pigs/">announced</a> in late 2009 and for all these years till now baumgarr has been devoting his free time and effort into building Nevernote and then Nixnote 2. The years of dedicated volunteer job deserve a lot of respect.</p>

<p>However I must confess that I consider several engineering solutions implemented in Nixnote 2 corner-cutting shortcuts and oversimplifications for the increased speed of development. I&rsquo;ll mention some of them here, for completeness:</p>

<ul>
<li>The first such shortcut is the use of <code>QSqlTableModel</code> and relatives. These Qt classes are indeed very convenient but they talk to the SQLite database synchronously, in the UI thread. For large enough databases that has the potential to totally screw up the performance.</li>
<li>The second shortcut is the use of global variables. Nixnote 2 has a special class “globals” which mostly consists of a bunch of different app settings. It is used a lot across the whole code of the app. Everybody knows why global variables are bad – they tighten the binding between components and thus increase the potential for the code to become spaghetti.</li>
<li>The third shortcut is the ad-hoc style of conversions between ENML and HTML representations of the note. The conversion is basically just a linear search and replace of some pre-specified markup fragments. The proper approach as I see it should involve iterating over the DOM tree of the HTML document and working with its elements, attributes and their contents. That is what I implemented in <a href="https://github.com/d1vanov/libquentier">libquentier</a> (the core library of Quentier). I did it using the conversion of HTML to a valid XML and then using Qt&rsquo;s standard XML reading/writing facilities. Nixnote 2 could do the same because it also uses HTML tidy – the tool capable of making HTML a well formed XML. Speaking of which, originally Nixnote 2 used the tool via launching it as another process which is not quite as performant as making library calls – several months ago such option was added to Nixnote 2.</li>
</ul>

<p>I could continue this list but I&rsquo;d stop here as that&rsquo;s enough to briefly represent my view on Nixnote 2&rsquo;s engineering issues. Despite these issues Nixnote 2 has nevertheless become successful – it has been included into Debian which does mean something in my opinion. Currently it is much more stable and usable than it was years ago.</p>

<p>Returning back to my story, I decided to continue the development of Quentier. Beyond the lack of ensureness in Nixnote 2&rsquo;s success the determining factors in my decision were the following:</p>

<ol>
<li>For the end user of the software it never hurts to have a choice so the existence of Nixnote 2 doesn&rsquo;t mean Quentier won&rsquo;t be needed by anyone ever.</li>
<li>Quentier still nicely plays the role of a playground project for self-learning.</li>
<li>I also realized that having a finished pet project capable of doing something useful would be a very nice portfolio item should I decide to change job.</li>
</ol>

<p>I&rsquo;d like to specifically note that I decided to not copy-paste any code from Nixnote 2 even though it was written in C++ and used Qt. The rationale was the following:</p>

<ol>
<li>Nixnote 2 is licensed under GPL and I wanted to have the core library licensed under LGPL.</li>
<li>If I start to copy-paste someone else&rsquo;s code, that would diminish the self-learning role of the project.</li>
</ol>

<p>I learned a lot from viewing the progress of Nixnote 2 – I watched its GitHub repository, saw problems which users encountered and features they wanted and suggested. It taught me a lot and some of that knowledge was shamelessly used in Quentier project.</p>

<p>Shortly after my decision to continue the work on Quentier despite the existence of Nixnote 2 I learned that the original author of QEverCloud library decided to resign from maintaining it. As by that time a lot of my code depended on QEverCloud I decided to volunteer becoming the next maintainer. I got the blessing from the original author as well as the code used to produce the auto-generated headers and sources of QEverCloud – <a href="https://github.com/d1vanov/QEverCloudGenerator">QEverCloudGenerator</a>. One thing I felt QEverCloud is lacking is the ability to be used as a shared library so I added such support. Another thing I did was the switch from <code>qmake</code> build system to <code>CMake</code>.</p>

<p>A major milestone in Quentier development was finalizing the local storage management and covering it with unit tests. The coverage is still not 100% but it is rather good. The hardest part of the entire development, I think, was implementing the Evernote search syntax support within the local storage. I guess finishing it (and covering with tests) was the absolute point of no return after which the sunk cost psychology would not let me cease the development no matter what happens.</p>

<p>The next thing to implement after the local storage which I chose to do was the note editor. I started it from scratch using <code>QtWebKit</code> as the backend. As a lot of stuff about HTML, CSS and JavaScript was new to me, I progressed quite slowly and had to read a lot of literature to make myself familiar with the basics of these technologies. I&rsquo;ve even read David Flanagan&rsquo;s “Javascript. The definitive guide” – a huge manuscript of ~1500 pages covering a whole lot of information. After several months of work I had some basic note editor with support for resources (attachments to notes) and simple actions like font size/family adjustment and stuff like that. I should have probably stopped at this for the first version but I didn’t. Instead I decided to implement smart undo/redo support for the note editor and some other fancy things like the support for resizable table columns. It all took several more months of work, involved a fair share of scripting but the end result got me really proud.</p>

<p>Unfortunately, there was another disappointment waiting for me just around the corner: Qt decided to deprecate <code>QtWebKit</code> module in favour of newish <code>QtWebEngine</code>. The more I learned about the differences between the two web modules the more frustrated I became: <code>QtWebEngine</code> was almost entirely asynchronous unlike the synchronous <code>QtWebKit</code> but much worse was another fact: the entire web plugin based API was missing in <code>QtWebEngine</code>. The official statement was like “with HTML5 nobody needs web plugins anymore”. Aha, sure. Probably I should have just ignored that deprecation but I once again couldn’t resist the challenge and spent several more months supporting <code>QtWebEngine</code> backend in addition to <code>QtWebKit</code>. For <code>QtWebEngine</code> I replaced web plugins with programmatically generated resource (attachment) representing images which were also additionally scripted to catch the clicks on “Open” and “Save” buttons rendered on them.</p>

<p>As a result of supporting both <code>QtWebKit</code> and <code>QtWebEngine</code> the source code of the note editor has become the messiest code of the entire project. It is full of <code>ifdef</code>s splitting the pieces of logics required for different backends plus I did a lot of things via JavaScript even when <code>QtWebKit</code> and <code>QtWebEngine</code> had some incompatible C++ APIs for them – they were too different + most C++ APIs for <code>QtWebEngine</code> appear only in the latest and greatest versions of Qt5 while I wanted to keep compatibility with as many Qt versions as possible.</p>

<p>The rest of Quentier’s development after the note editor was much less dramatic which was very fortunate for me since I started to get really tired of all these unexpected issues. I implemented the synchronization logics but before I could test it properly I needed to implement the rest of UI components and piece them together to form the bulk of the app which one can interact with. I decided to use Qt’s model-view framework for lists of notebooks, notes, tags etc. Notebooks and tags are actually represented by tree models: notebooks can be nested into stacks + they can correspond to linked notebooks instead of user’s own account; tags can be nested into each other + they can also come from linked notebooks’ notes. Implementing models and some custom delegates took several months but it was worth it: now I feel like <code>QAbstractItemModel</code> is my best understood part of Qt framework.</p>

<p>I first compiled the pieces together into an app in the beginning of 2017 and the rest of the year was spent on implementing various small missing pieces of functionality and troubleshooting. Finally the whole thing was published on GitHub.</p>

<p>Looking back now I can see the history of Quentier project is full of operational mistakes: I should have studied the landscape better and found out about the existence of Nixnote 2 much earlier, ideally before I started to tinker with anything. I should have invested more effort into building the high level design of the app in the very beginning of the project. Finally, once I had some blueprint I should have probably started to develop things in public – that might have attracted people with good suggestions and skills. If I ever start any open source project again, I’ll definitely try to avoid the same mistakes. Hopefully someone would be able to avoid such mistakes after reading about my experience.</p>

<p>A logical conclusion to this post would be some estimation about the future of Quentier project. I plan to continue working on it but I might have to slow down a little because I’ve accumulated some “technical debt” in my life during several previous years of development and I need to &ldquo;pay&rdquo; it now. I really hope someone would join the development, at least in the form of bug reports and maybe patches. I would also enjoy to see someone willing to work on some new functionality and improving the existing one as well. So what I definitely intend to do is to make the project as developer-friendly as possible: write more developer docs, especially the introductory ones + factor out some “junior jobs” and mark them appropriately. Then time will tell whether there&rsquo;s any public interest in Quentier: if the project manages to attract both developers and users, it&rsquo;s development would most likely continue even if I choose to step aside (although right now I don&rsquo;t have such plans).</p>

<p>Also one more note about Quentier&rsquo;s potential connections with Nixnote 2: even though playing on the same field makes us competitors, I’m not really a person who is into competition. I would much rather collaborate than compete. I think the appearance of Quentier is good for Nixnote 2 since it can definitely take some pieces from it, for example, the C++ code for encrypting/decrypting the note fragments. Currently Nixnote 2 still requires Java only for that functionality. To foresee the next question, I don’t think it would be possible to merge the two projects together: after all, they are very different architecturally. But I think these two projects can definitely become good neighbours.</p>

<p>I guess that&rsquo;s more than enough for the introductory post. I plan to write more on many things which I feel should be communicated so stay tuned.</p>

  </div>
  
  
</div>


  </body>
</html>
